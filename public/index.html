<script src="/socket.io/socket.io.js"></script>
<script>
  const canvas = document.getElementById("board");
  const ctx = canvas.getContext("2d");
  const socket = io({
    transports: ['websocket']
  });

  const colorPicker = document.getElementById("colorPicker");
  const clearMineBtn = document.getElementById("clearMineBtn");
  const clearAllBtn = document.getElementById("clearAllBtn");
  const userLabel = document.getElementById("userLabel");

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resizeCanvas();
  window.addEventListener("resize", resizeCanvas);

  let drawing = false;
  let color = colorPicker.value;
  let myUserId = null;

  // ===== SESSION USER ID (PER TAB) =====
  myUserId = sessionStorage.getItem("whiteboardSessionUserId");
  if (!myUserId) {
    myUserId = Math.random().toString(36).substring(2, 7).toUpperCase();
    sessionStorage.setItem("whiteboardSessionUserId", myUserId);
  }

  // --- REGISTRATION ---
  socket.emit("register", { userId: myUserId });

  // Server sends back confirmation
  socket.on("user-info", (info) => {
    myUserId = info.userId;
    userLabel.textContent = `You: ${myUserId}`;
  });

  // CRITICAL: Received entire history on connection from Redis
  socket.on("init-board", (strokes) => {
    console.log(`Board initialized with ${strokes.length} persisted strokes.`);
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Start clean
    strokes.forEach((s) => drawPoint(s.x, s.y, s.color));
  });

  colorPicker.addEventListener("change", (e) => {
    color = e.target.value;
  });

  // ✅ CLEAR ONLY MY STROKES (Server handles filtering against persistent store)
  clearMineBtn.addEventListener("click", () => {
    socket.emit("clear-mine");
  });

  // ✅ CLEAR EVERYONE (Server deletes the persistent store)
  clearAllBtn.addEventListener("click", () => {
    socket.emit("clear-all");
  });

  // --- DRAWING LISTENERS ---
  canvas.addEventListener("mousedown", () => (drawing = true));
  canvas.addEventListener("mouseup", () => (drawing = false));
  canvas.addEventListener("mouseleave", () => (drawing = false));
  canvas.addEventListener("mousemove", draw);

  function draw(e) {
    if (!drawing) return;

    const x = e.clientX;
    const y = e.clientY;

    const data = { x, y, color }; // userId is added by the server

    // 1. Draw LOCALLY first for zero-latency feedback
    drawPoint(x, y, color);

    // 2. Send draw data to the server for persistence and broadcast
    socket.emit("draw", data);
  }

  // --- SERVER EVENTS ---

  // Received draw events from OTHER users
  socket.on("draw", (data) => {
    drawPoint(data.x, data.y, data.color);
  });

  // Server tells all clients to clear the canvas
  socket.on("clear-all", () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  });

  // CRITICAL: Server tells everyone to clear and redraw the filtered state
  socket.on("reset-board", (strokes) => {
    console.log(`Board reset, ${strokes.length} strokes redrawn from persistent store.`);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    strokes.forEach((s) => drawPoint(s.x, s.y, s.color));
  });

  function drawPoint(x, y, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, Math.PI * 2);
    ctx.fill();
  }
</script>